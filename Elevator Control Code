-- Elevator Controller Code --

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY ElevatorController IS
    GENERIC(
        NumFloors : integer := 4;
        TravelTime : integer := 2; 
        DoorTime : integer := 3
    );
    PORT(
        clk : IN STD_LOGIC;
        HardReset : IN STD_LOGIC;
        SoftReset : IN STD_LOGIC;
        estop : IN STD_LOGIC;
        tick : IN STD_LOGIC;
        ReqButtons : IN STD_LOGIC_VECTOR(NumFloors - 1 downto 0);
        
        CurrentFloor : OUT integer range 0 to NumFloors - 1;
        DoorOpen : OUT STD_LOGIC;
        MovingUp : OUT STD_LOGIC;
        MovingDown : OUT STD_LOGIC;
        debugger : OUT STD_LOGIC_VECTOR(2 downto 0)
    );
END ElevatorController;

ARCHITECHTURE Behavioral of ElevatorController IS

    type stateType IS (IDLE, MOVE_UP, MOVE_DOWN, CHECK_STOP, DOOR_OPEN, ESTOP_STATE);
    signal state : stateType;
    signal CurrentFloor : integer range 0 to NumFloors - 1;
    signal requests : std_logic_vector(NumFloors - 1 downto 0);
    signal timer : integer range 0 to 10;
    signal LastDirUp : std_logic := '1'; 

BEGIN
    process(clk, HardReset)
        variable ReqUp : boolean;
        variable ReqDown : boolean;

    BEGIN
        if HardReset = '1' then
            state <= IDLE;
            CurrentFloor <= 0;
            requests <= (others => '0');
            timer <= 0;
            LastDirUp <= '1';
            
        elsif rising_edge(clk) then
            for i in 0 to NumFloors - 1 loop
                if ReqButtons(i) = '1' then
                    requests(i) <= '1';
                end if;
            END loop;

            ReqUp := false;
            ReqDown := false;
            for i in 0 to NumFloors - 1 loop
                if i > CurrentFloor and requests(i) = '1' then
                    ReqUp := true; 
                END if;

                if i < CurrentFloor and requests(i) = '1' then
                    ReqDown := true; end if;
            END loop;

            -- This part is the Moore FSM

            if SoftReset = '1' then
                requests <= (others => '0');
            elsif estop = '1' then
                state <= ESTOP_STATE;
            else
                case state is
                    when IDLE =>
                        timer <= 0;
                        if requests(CurrentFloor) = '1' then
                            state <= S_DOOR_OPEN;
                        elsif LastDirUp = '1' and ReqUp then
                            state <= MOVE_UP;
                        elsif LastDirUp = '0' and ReqDown then
                            state <= MOVE_DOWN;
                        elsif ReqUp then
                            state <= MOVE_UP;
                            LastDirUp <= '1';
                        elsif ReqDown then
                            state <= MOVE_DOWN;
                            LastDirUp <= '0';
                        END if;

                    when MOVE_UP => if tick = '1' then
                            if timer < TRAVEL_TIME - 1 then
                                timer <= timer + 1;
                            else
                                timer <= 0;
                                if CurrentFloor < NumFloors - 1 then
                                    CurrentFloor <= CurrentFloor + 1;
                                end if;
                                state <= CHECK_STOP; 
                                LastDirUp <= '1';
                            end if;
                        end if;

                    when MOVE_DOWN => if tick = '1' then
                            if timer < TRAVEL_TIME - 1 then
                                timer <= timer + 1;
                            else
                                timer <= 0;
                                if CurrentFloor > 0 then
                                    CurrentFloor <= CurrentFloor - 1;
                                end if;
                                state <= CHECK_STOP;
                                LastDirUp <= '0';
                            end if;
                        end if;

                    when CHECK_STOP => if requests(CurrentFloor) = '1' then
                            state <= S_DOOR_OPEN;
                        elsif LastDirUp = '1' and ReqUp then
                            state <= MOVE_UP;
                        elsif LastDirUp = '0' and ReqDown then
                            state <= MOVE_DOWN;
                        else
                            state <= IDLE;
                        end if;

                    when S_DOOR_OPEN => requests(CurrentFloor) <= '0'; 
                        if tick = '1' then
                            if timer < DOOR_TIME - 1 then
                                timer <= timer + 1;
                            else
                                timer <= 0;
                                state <= IDLE;
                            end if;
                        end if;

                    when ESTOP_STATE =>
                        if estop = '0' then state <= IDLE; end if;
                        
                end case;
            end if;
        end if;
    end process;


    current_floor <= CurrentFloor;
    DoorOpen     <= '1' when state = S_DOOR_OPEN else '0';
    MovingUp     <= '1' when state = MOVE_UP else '0';
    MovingDown   <= '1' when state = MOVE_DOWN else '0';
    
    with state select debug <=
        "000" when IDLE, "001" when MOVE_UP, "010" when MOVE_DOWN, 
        "011" when S_DOOR_OPEN, "100" when ESTOP_STATE, "101" when CHECK_STOP, "111" when others;

end Behavioral;
